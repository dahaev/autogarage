// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: cars.sql

package db

import (
	"context"
)

const createCar = `-- name: CreateCar :one
INSERT INTO cars (
        model_name,
        equipment,
        color,
        country,
        price,
        valid

) VALUES (
             $1,$2,$3,$4,$5,$6
         )
    RETURNING id, model_name, equipment, color, country, price, valid, created_at
`

type CreateCarParams struct {
	ModelName string `json:"model_name"`
	Equipment string `json:"equipment"`
	Color     string `json:"color"`
	Country   string `json:"country"`
	Price     int64  `json:"price"`
	Valid     string `json:"valid"`
}

func (q *Queries) CreateCar(ctx context.Context, arg CreateCarParams) (Car, error) {
	row := q.db.QueryRowContext(ctx, createCar,
		arg.ModelName,
		arg.Equipment,
		arg.Color,
		arg.Country,
		arg.Price,
		arg.Valid,
	)
	var i Car
	err := row.Scan(
		&i.ID,
		&i.ModelName,
		&i.Equipment,
		&i.Color,
		&i.Country,
		&i.Price,
		&i.Valid,
		&i.CreatedAt,
	)
	return i, err
}

const getCar = `-- name: GetCar :one
SELECT id, model_name, equipment, color, country, price, valid, created_at FROM cars
WHERE id = $1
`

func (q *Queries) GetCar(ctx context.Context, id int64) (Car, error) {
	row := q.db.QueryRowContext(ctx, getCar, id)
	var i Car
	err := row.Scan(
		&i.ID,
		&i.ModelName,
		&i.Equipment,
		&i.Color,
		&i.Country,
		&i.Price,
		&i.Valid,
		&i.CreatedAt,
	)
	return i, err
}

const getCarForUpdate = `-- name: GetCarForUpdate :one
SELECT id, model_name, equipment, color, country, price, valid, created_at FROM cars
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetCarForUpdate(ctx context.Context, id int64) (Car, error) {
	row := q.db.QueryRowContext(ctx, getCarForUpdate, id)
	var i Car
	err := row.Scan(
		&i.ID,
		&i.ModelName,
		&i.Equipment,
		&i.Color,
		&i.Country,
		&i.Price,
		&i.Valid,
		&i.CreatedAt,
	)
	return i, err
}

const listCars = `-- name: ListCars :many
SELECT id, model_name, equipment, color, country, price, valid, created_at FROM cars
ORDER BY model_name
    LIMIT $1
OFFSET $2
`

type ListCarsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCars(ctx context.Context, arg ListCarsParams) ([]Car, error) {
	rows, err := q.db.QueryContext(ctx, listCars, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Car
	for rows.Next() {
		var i Car
		if err := rows.Scan(
			&i.ID,
			&i.ModelName,
			&i.Equipment,
			&i.Color,
			&i.Country,
			&i.Price,
			&i.Valid,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCar = `-- name: UpdateCar :one
UPDATE cars
set model_name = $2,
    equipment = $3,
    color = $4,
    country = $5,
    price = $6,
    valid = $7
WHERE id=$1
    RETURNING id, model_name, equipment, color, country, price, valid, created_at
`

type UpdateCarParams struct {
	ID        int64  `json:"id"`
	ModelName string `json:"model_name"`
	Equipment string `json:"equipment"`
	Color     string `json:"color"`
	Country   string `json:"country"`
	Price     int64  `json:"price"`
	Valid     string `json:"valid"`
}

func (q *Queries) UpdateCar(ctx context.Context, arg UpdateCarParams) (Car, error) {
	row := q.db.QueryRowContext(ctx, updateCar,
		arg.ID,
		arg.ModelName,
		arg.Equipment,
		arg.Color,
		arg.Country,
		arg.Price,
		arg.Valid,
	)
	var i Car
	err := row.Scan(
		&i.ID,
		&i.ModelName,
		&i.Equipment,
		&i.Color,
		&i.Country,
		&i.Price,
		&i.Valid,
		&i.CreatedAt,
	)
	return i, err
}
